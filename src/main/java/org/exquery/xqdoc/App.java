package org.exquery.xqdoc;

import org.xqdoc.conversion.XQDocController;
import org.xqdoc.conversion.XQDocException;
import org.xqdoc.conversion.XQDocPayload;
import org.xqdoc.drivers.marklogic.MarkLogicDriver;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.HashMap;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        XQDocController controller = null;
        try {
            controller = new XQDocController(
                    XQDocController.JUL2017);
            HashMap uriMap = new HashMap();
            uriMap.put(MarkLogicDriver.CTS_PREFIX, MarkLogicDriver.CTS_URI);
            uriMap.put(MarkLogicDriver.XDMP_PREFIX, MarkLogicDriver.XDMP_URI);
            uriMap.put(MarkLogicDriver.XPATH_PREFIX, MarkLogicDriver.XPATH_URI);
            controller.setPredefinedFunctionNamespaces(uriMap);

            StringBuffer buff = new StringBuffer();

            buff.append("xquery version \"1.0\";\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append("\n");
            buff.append(" : --------------------------------\n");
            buff.append(" : The FunctX XQuery Function Library\n");
            buff.append(" : --------------------------------\n");
            buff.append("\n");
            buff.append(" : Copyright (C) 2007 Datypic\n");
            buff.append("\n");
            buff.append(" : This library is free software; you can redistribute it and/or\n");
            buff.append(" : modify it under the terms of the GNU Lesser General Public\n");
            buff.append(" : License as published by the Free Software Foundation; either\n");
            buff.append(" : version 2.1 of the License.\n");
            buff.append("\n");
            buff.append(" : This library is distributed in the hope that it will be useful,\n");
            buff.append(" : but WITHOUT ANY WARRANTY; without even the implied warranty of\n");
            buff.append(" : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n");
            buff.append(" : Lesser General Public License for more details.\n");
            buff.append("\n");
            buff.append(" : You should have received a copy of the GNU Lesser General Public\n");
            buff.append(" : License along with this library; if not, write to the Free Software\n");
            buff.append(" : Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n");
            buff.append("\n");
            buff.append(" : For more information on the FunctX XQuery library, contact contrib@functx.com.\n");
            buff.append("\n");
            buff.append(" : @version 1.0\n");
            buff.append(" : @see     http://www.xqueryfunctions.com\n");
            buff.append(" :) \n");
            buff.append("module namespace  functx = \"http://www.functx.com\" ;\n");
            buff.append(" \n");
            buff.append("(:~\n");
            buff.append(" : Adds attributes to XML elements \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_add-attributes.html \n");
            buff.append(" : @param   $elements the element(s) to which you wish to add the attribute \n");
            buff.append(" : @param   $attrNames the name(s) of the attribute(s) to add \n");
            buff.append(" : @param   $attrValues the value(s) of the attribute(s) to add \n");
            buff.append(" :) \n");
            buff.append("declare function functx:add-attributes \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $attrNames as xs:QName* ,\n");
            buff.append("    $attrValues as xs:anyAtomicType* )  as element()? {\n");
            buff.append("       \n");
            buff.append("   for $element in $elements\n");
            buff.append("   return element { node-name($element)}\n");
            buff.append("                  { for $attrName at $seq in $attrNames\n");
            buff.append("                    return if ($element/@*[node-name(.) = $attrName])\n");
            buff.append("                           then ()\n");
            buff.append("                           else attribute {$attrName}\n");
            buff.append("                                          {$attrValues[$seq]},\n");
            buff.append("                    $element/@*,\n");
            buff.append("                    $element/node() }\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Adds months to a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_add-months.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" : @param   $months the number of months to add \n");
            buff.append(" :) \n");
            buff.append("declare function functx:add-months \n");
            buff.append("  ( $date as xs:anyAtomicType? ,\n");
            buff.append("    $months as xs:integer )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   xs:date($date) + functx:yearMonthDuration(0,$months)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Adds attributes to XML elements \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html \n");
            buff.append(" : @param   $elements the element(s) to which you wish to add the attribute \n");
            buff.append(" : @param   $attrNames the name(s) of the attribute(s) to add \n");
            buff.append(" : @param   $attrValues the value(s) of the attribute(s) to add \n");
            buff.append(" :) \n");
            buff.append("declare function functx:add-or-update-attributes \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $attrNames as xs:QName* ,\n");
            buff.append("    $attrValues as xs:anyAtomicType* )  as element()? {\n");
            buff.append("       \n");
            buff.append("   for $element in $elements\n");
            buff.append("   return element { node-name($element)}\n");
            buff.append("                  { for $attrName at $seq in $attrNames\n");
            buff.append("                    return attribute {$attrName}\n");
            buff.append("                                     {$attrValues[$seq]},\n");
            buff.append("                    $element/@*[not(node-name(.) = $attrNames)],\n");
            buff.append("                    $element/node() }\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a value is all whitespace or a zero-length string \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_all-whitespace.html \n");
            buff.append(" : @param   $arg the string (or node) to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:all-whitespace \n");
            buff.append("  ( $arg as xs:string? )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   normalize-space($arg) = ''\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether all the values in a sequence are distinct \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_are-distinct-values.html \n");
            buff.append(" : @param   $seq the sequence of values \n");
            buff.append(" :) \n");
            buff.append("declare function functx:are-distinct-values \n");
            buff.append("  ( $seq as xs:anyAtomicType* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   count(distinct-values($seq)) = count($seq)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The built-in type of an atomic value \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_atomic-type.html \n");
            buff.append(" : @param   $values the value(s) whose type you want to determine \n");
            buff.append(" :) \n");
            buff.append("declare function functx:atomic-type \n");
            buff.append("  ( $values as xs:anyAtomicType* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append(" for $val in $values\n");
            buff.append(" return\n");
            buff.append(" (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic'\n");
            buff.append(" else if ($val instance of xs:anyURI) then 'xs:anyURI'\n");
            buff.append(" else if ($val instance of xs:ENTITY) then 'xs:ENTITY'\n");
            buff.append(" else if ($val instance of xs:ID) then 'xs:ID'\n");
            buff.append(" else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN'\n");
            buff.append(" else if ($val instance of xs:language) then 'xs:language'\n");
            buff.append(" else if ($val instance of xs:NCName) then 'xs:NCName'\n");
            buff.append(" else if ($val instance of xs:Name) then 'xs:Name'\n");
            buff.append(" else if ($val instance of xs:token) then 'xs:token'\n");
            buff.append(" else if ($val instance of xs:normalizedString)\n");
            buff.append("         then 'xs:normalizedString'\n");
            buff.append(" else if ($val instance of xs:string) then 'xs:string'\n");
            buff.append(" else if ($val instance of xs:QName) then 'xs:QName'\n");
            buff.append(" else if ($val instance of xs:boolean) then 'xs:boolean'\n");
            buff.append(" else if ($val instance of xs:base64Binary) then 'xs:base64Binary'\n");
            buff.append(" else if ($val instance of xs:hexBinary) then 'xs:hexBinary'\n");
            buff.append(" else if ($val instance of xs:byte) then 'xs:byte'\n");
            buff.append(" else if ($val instance of xs:short) then 'xs:short'\n");
            buff.append(" else if ($val instance of xs:int) then 'xs:int'\n");
            buff.append(" else if ($val instance of xs:long) then 'xs:long'\n");
            buff.append(" else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte'\n");
            buff.append(" else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort'\n");
            buff.append(" else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt'\n");
            buff.append(" else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong'\n");
            buff.append(" else if ($val instance of xs:positiveInteger)\n");
            buff.append("         then 'xs:positiveInteger'\n");
            buff.append(" else if ($val instance of xs:nonNegativeInteger)\n");
            buff.append("         then 'xs:nonNegativeInteger'\n");
            buff.append(" else if ($val instance of xs:negativeInteger)\n");
            buff.append("         then 'xs:negativeInteger'\n");
            buff.append(" else if ($val instance of xs:nonPositiveInteger)\n");
            buff.append("         then 'xs:nonPositiveInteger'\n");
            buff.append(" else if ($val instance of xs:integer) then 'xs:integer'\n");
            buff.append(" else if ($val instance of xs:decimal) then 'xs:decimal'\n");
            buff.append(" else if ($val instance of xs:float) then 'xs:float'\n");
            buff.append(" else if ($val instance of xs:double) then 'xs:double'\n");
            buff.append(" else if ($val instance of xs:date) then 'xs:date'\n");
            buff.append(" else if ($val instance of xs:time) then 'xs:time'\n");
            buff.append(" else if ($val instance of xs:dateTime) then 'xs:dateTime'\n");
            buff.append(" else if ($val instance of xs:dayTimeDuration)\n");
            buff.append("         then 'xs:dayTimeDuration'\n");
            buff.append(" else if ($val instance of xs:yearMonthDuration)\n");
            buff.append("         then 'xs:yearMonthDuration'\n");
            buff.append(" else if ($val instance of xs:duration) then 'xs:duration'\n");
            buff.append(" else if ($val instance of xs:gMonth) then 'xs:gMonth'\n");
            buff.append(" else if ($val instance of xs:gYear) then 'xs:gYear'\n");
            buff.append(" else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth'\n");
            buff.append(" else if ($val instance of xs:gDay) then 'xs:gDay'\n");
            buff.append(" else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay'\n");
            buff.append(" else 'unknown')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The average, counting \"empty\" values as zero \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_avg-empty-is-zero.html \n");
            buff.append(" : @param   $values the values to be averaged \n");
            buff.append(" : @param   $allNodes the sequence of all nodes to find the average over \n");
            buff.append(" :) \n");
            buff.append("declare function functx:avg-empty-is-zero \n");
            buff.append("  ( $values as xs:anyAtomicType* ,\n");
            buff.append("    $allNodes as node()* )  as xs:double {\n");
            buff.append("       \n");
            buff.append("   if (empty($allNodes))\n");
            buff.append("   then 0\n");
            buff.append("   else sum($values[string(.) != '']) div count($allNodes)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a value is between two provided values \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_between-exclusive.html \n");
            buff.append(" : @param   $value the value to be tested \n");
            buff.append(" : @param   $minValue the minimum value \n");
            buff.append(" : @param   $maxValue the maximum value \n");
            buff.append(" :) \n");
            buff.append("declare function functx:between-exclusive \n");
            buff.append("  ( $value as xs:anyAtomicType? ,\n");
            buff.append("    $minValue as xs:anyAtomicType ,\n");
            buff.append("    $maxValue as xs:anyAtomicType )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $value > $minValue and $value < $maxValue\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a value is between two provided values, or equal to one of them \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_between-inclusive.html \n");
            buff.append(" : @param   $value the value to be tested \n");
            buff.append(" : @param   $minValue the minimum value \n");
            buff.append(" : @param   $maxValue the maximum value \n");
            buff.append(" :) \n");
            buff.append("declare function functx:between-inclusive \n");
            buff.append("  ( $value as xs:anyAtomicType? ,\n");
            buff.append("    $minValue as xs:anyAtomicType ,\n");
            buff.append("    $maxValue as xs:anyAtomicType )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $value >= $minValue and $value <= $maxValue\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Turns a camelCase string into space-separated words \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_camel-case-to-words.html \n");
            buff.append(" : @param   $arg the string to modify \n");
            buff.append(" : @param   $delim the delimiter for the words (e.g. a space) \n");
            buff.append(" :) \n");
            buff.append("declare function functx:camel-case-to-words \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $delim as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   concat(substring($arg,1,1),\n");
            buff.append("             replace(substring($arg,2),'(\\p{Lu})',\n");
            buff.append("                        concat($delim, '$1')))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Capitalizes the first character of a string \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_capitalize-first.html \n");
            buff.append(" : @param   $arg the word or phrase to capitalize \n");
            buff.append(" :) \n");
            buff.append("declare function functx:capitalize-first \n");
            buff.append("  ( $arg as xs:string? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   concat(upper-case(substring($arg,1,1)),\n");
            buff.append("             substring($arg,2))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Changes the names of elements in an XML fragment \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_change-element-names-deep.html \n");
            buff.append(" : @param   $nodes the element(s) to change \n");
            buff.append(" : @param   $oldNames the sequence of names to change from \n");
            buff.append(" : @param   $newNames the sequence of names to change to \n");
            buff.append(" :) \n");
            buff.append("declare function functx:change-element-names-deep \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $oldNames as xs:QName* ,\n");
            buff.append("    $newNames as xs:QName* )  as node()* {\n");
            buff.append("       \n");
            buff.append("  if (count($oldNames) != count($newNames))\n");
            buff.append("  then error(xs:QName('functx:Different_number_of_names'))\n");
            buff.append("  else\n");
            buff.append("   for $node in $nodes\n");
            buff.append("   return if ($node instance of element())\n");
            buff.append("          then element\n");
            buff.append("                 {functx:if-empty\n");
            buff.append("                    ($newNames[index-of($oldNames,\n");
            buff.append("                                           node-name($node))],\n");
            buff.append("                     node-name($node)) }\n");
            buff.append("                 {$node/@*,\n");
            buff.append("                  functx:change-element-names-deep($node/node(),\n");
            buff.append("                                           $oldNames, $newNames)}\n");
            buff.append("          else if ($node instance of document-node())\n");
            buff.append("          then functx:change-element-names-deep($node/node(),\n");
            buff.append("                                           $oldNames, $newNames)\n");
            buff.append("          else $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Changes the namespace of XML elements and its descendants \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html \n");
            buff.append(" : @param   $nodes the nodes to change \n");
            buff.append(" : @param   $newns the new namespace \n");
            buff.append(" : @param   $prefix the prefix to use for the new namespace \n");
            buff.append(" :) \n");
            buff.append("declare function functx:change-element-ns-deep \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $newns as xs:string ,\n");
            buff.append("    $prefix as xs:string )  as node()* {\n");
            buff.append("       \n");
            buff.append("  for $node in $nodes\n");
            buff.append("  return if ($node instance of element())\n");
            buff.append("         then (element\n");
            buff.append("               {QName ($newns,\n");
            buff.append("                          concat($prefix,\n");
            buff.append("                                    if ($prefix = '')\n");
            buff.append("                                    then ''\n");
            buff.append("                                    else ':',\n");
            buff.append("                                    local-name($node)))}\n");
            buff.append("               {$node/@*,\n");
            buff.append("                functx:change-element-ns-deep($node/node(),\n");
            buff.append("                                           $newns, $prefix)})\n");
            buff.append("         else if ($node instance of document-node())\n");
            buff.append("         then functx:change-element-ns-deep($node/node(),\n");
            buff.append("                                           $newns, $prefix)\n");
            buff.append("         else $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Changes the namespace of XML elements \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_change-element-ns.html \n");
            buff.append(" : @param   $elements the elements to change \n");
            buff.append(" : @param   $newns the new namespace \n");
            buff.append(" : @param   $prefix the prefix to use for the new namespace \n");
            buff.append(" :) \n");
            buff.append("declare function functx:change-element-ns \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $newns as xs:string ,\n");
            buff.append("    $prefix as xs:string )  as element()? {\n");
            buff.append("       \n");
            buff.append("   for $element in $elements\n");
            buff.append("   return\n");
            buff.append("   element {QName ($newns,\n");
            buff.append("                      concat($prefix,\n");
            buff.append("                                if ($prefix = '')\n");
            buff.append("                                then ''\n");
            buff.append("                                else ':',\n");
            buff.append("                                local-name($element)))}\n");
            buff.append("           {$element/@*, $element/node()}\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Converts a string to a sequence of characters \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_chars.html \n");
            buff.append(" : @param   $arg the string to split \n");
            buff.append(" :) \n");
            buff.append("declare function functx:chars \n");
            buff.append("  ( $arg as xs:string? )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   for $ch in string-to-codepoints($arg)\n");
            buff.append("   return codepoints-to-string($ch)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a string contains any of a sequence of strings \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_contains-any-of.html \n");
            buff.append(" : @param   $arg the string to test \n");
            buff.append(" : @param   $searchStrings the strings to look for \n");
            buff.append(" :) \n");
            buff.append("declare function functx:contains-any-of \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $searchStrings as xs:string* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   some $searchString in $searchStrings\n");
            buff.append("   satisfies contains($arg,$searchString)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether one string contains another, without regard to case \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html \n");
            buff.append(" : @param   $arg the string to search \n");
            buff.append(" : @param   $substring the substring to find \n");
            buff.append(" :) \n");
            buff.append("declare function functx:contains-case-insensitive \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $substring as xs:string )  as xs:boolean? {\n");
            buff.append("       \n");
            buff.append("   contains(upper-case($arg), upper-case($substring))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether one string contains another, as a separate word \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_contains-word.html \n");
            buff.append(" : @param   $arg the string to search \n");
            buff.append(" : @param   $word the word to find \n");
            buff.append(" :) \n");
            buff.append("declare function functx:contains-word \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $word as xs:string )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   matches(upper-case($arg),\n");
            buff.append("           concat('^(.*\\W)?',\n");
            buff.append("                     upper-case(functx:escape-for-regex($word)),\n");
            buff.append("                     '(\\W.*)?$'))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Copies attributes from one element to another \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_copy-attributes.html \n");
            buff.append(" : @param   $copyTo the element to copy attributes to \n");
            buff.append(" : @param   $copyFrom the element to copy attributes from \n");
            buff.append(" :) \n");
            buff.append("declare function functx:copy-attributes \n");
            buff.append("  ( $copyTo as element() ,\n");
            buff.append("    $copyFrom as element() )  as element() {\n");
            buff.append("       \n");
            buff.append("   element { node-name($copyTo)}\n");
            buff.append("           { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))],\n");
            buff.append("             $copyFrom/@*,\n");
            buff.append("             $copyTo/node() }\n");
            buff.append("\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Construct a date from a year, month and day \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_date.html \n");
            buff.append(" : @param   $year the year \n");
            buff.append(" : @param   $month the month \n");
            buff.append(" : @param   $day the day \n");
            buff.append(" :) \n");
            buff.append("declare function functx:date \n");
            buff.append("  ( $year as xs:anyAtomicType ,\n");
            buff.append("    $month as xs:anyAtomicType ,\n");
            buff.append("    $day as xs:anyAtomicType )  as xs:date {\n");
            buff.append("       \n");
            buff.append("   xs:date(\n");
            buff.append("     concat(\n");
            buff.append("       functx:pad-integer-to-length(xs:integer($year),4),'-',\n");
            buff.append("       functx:pad-integer-to-length(xs:integer($month),2),'-',\n");
            buff.append("       functx:pad-integer-to-length(xs:integer($day),2)))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Construct a date/time from individual components \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_datetime.html \n");
            buff.append(" : @param   $year the year \n");
            buff.append(" : @param   $month the month \n");
            buff.append(" : @param   $day the day \n");
            buff.append(" : @param   $hour the hour \n");
            buff.append(" : @param   $minute the minute \n");
            buff.append(" : @param   $second the second \n");
            buff.append(" :) \n");
            buff.append("declare function functx:dateTime \n");
            buff.append("  ( $year as xs:anyAtomicType ,\n");
            buff.append("    $month as xs:anyAtomicType ,\n");
            buff.append("    $day as xs:anyAtomicType ,\n");
            buff.append("    $hour as xs:anyAtomicType ,\n");
            buff.append("    $minute as xs:anyAtomicType ,\n");
            buff.append("    $second as xs:anyAtomicType )  as xs:dateTime {\n");
            buff.append("       \n");
            buff.append("   xs:dateTime(\n");
            buff.append("     concat(functx:date($year,$month,$day),'T',\n");
            buff.append("             functx:time($hour,$minute,$second)))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The day of the year (a number between 1 and 366) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_day-in-year.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:day-in-year \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("  days-from-duration(\n");
            buff.append("      xs:date($date) - functx:first-day-of-year($date)) + 1\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The abbreviated day of the week, from a date, in English \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:day-of-week-abbrev-en \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat')\n");
            buff.append("   [functx:day-of-week($date) + 1]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The name of the day of the week, from a date, in English \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:day-of-week-name-en \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   ('Sunday', 'Monday', 'Tuesday', 'Wednesday',\n");
            buff.append("    'Thursday', 'Friday', 'Saturday')\n");
            buff.append("      [functx:day-of-week($date) + 1]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The day of the week, from a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_day-of-week.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:day-of-week \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("  if (empty($date))\n");
            buff.append("  then ()\n");
            buff.append("  else xs:integer((xs:date($date) - xs:date('1901-01-06'))\n");
            buff.append("          div xs:dayTimeDuration('P1D')) mod 7\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Construct a dayTimeDuration from a number of days, hours, etc. \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_daytimeduration.html \n");
            buff.append(" : @param   $days the number of days \n");
            buff.append(" : @param   $hours the number of hours \n");
            buff.append(" : @param   $minutes the number of minutes \n");
            buff.append(" : @param   $seconds the number of seconds \n");
            buff.append(" :) \n");
            buff.append("declare function functx:dayTimeDuration \n");
            buff.append("  ( $days as xs:decimal? ,\n");
            buff.append("    $hours as xs:decimal? ,\n");
            buff.append("    $minutes as xs:decimal? ,\n");
            buff.append("    $seconds as xs:decimal? )  as xs:dayTimeDuration {\n");
            buff.append("       \n");
            buff.append("    (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) +\n");
            buff.append("    (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) +\n");
            buff.append("    (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) +\n");
            buff.append("    (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Number of days in the month \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_days-in-month.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:days-in-month \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("   if (month-from-date(xs:date($date)) = 2 and\n");
            buff.append("       functx:is-leap-year($date))\n");
            buff.append("   then 29\n");
            buff.append("   else\n");
            buff.append("   (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n");
            buff.append("    [month-from-date(xs:date($date))]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The depth (level) of a node in an XML tree \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_depth-of-node.html \n");
            buff.append(" : @param   $node the node to check \n");
            buff.append(" :) \n");
            buff.append("declare function functx:depth-of-node \n");
            buff.append("  ( $node as node()? )  as xs:integer {\n");
            buff.append("       \n");
            buff.append("   count($node/ancestor-or-self::node())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The distinct names of all attributes in an XML fragment \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_distinct-attribute-names.html \n");
            buff.append(" : @param   $nodes the root to start from \n");
            buff.append(" :) \n");
            buff.append("declare function functx:distinct-attribute-names \n");
            buff.append("  ( $nodes as node()* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   distinct-values($nodes//@*/name(.))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The XML nodes with distinct values, taking into account attributes and descendants \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_distinct-deep.html \n");
            buff.append(" : @param   $nodes the sequence of nodes to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:distinct-deep \n");
            buff.append("  ( $nodes as node()* )  as node()* {\n");
            buff.append("       \n");
            buff.append("    for $seq in (1 to count($nodes))\n");
            buff.append("    return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal(\n");
            buff.append("                          .,$nodes[position() < $seq]))]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The distinct names of all elements in an XML fragment \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_distinct-element-names.html \n");
            buff.append(" : @param   $nodes the root(s) to start from \n");
            buff.append(" :) \n");
            buff.append("declare function functx:distinct-element-names \n");
            buff.append("  ( $nodes as node()* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   distinct-values($nodes/descendant-or-self::*/name(.))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The distinct paths of all descendant elements in an XML fragment \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_distinct-element-paths.html \n");
            buff.append(" : @param   $nodes the root(s) to start from \n");
            buff.append(" :) \n");
            buff.append("declare function functx:distinct-element-paths \n");
            buff.append("  ( $nodes as node()* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   distinct-values(functx:path-to-node($nodes/descendant-or-self::*))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The distinct XML nodes in a sequence (by node identity) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html \n");
            buff.append(" : @param   $nodes the node sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:distinct-nodes \n");
            buff.append("  ( $nodes as node()* )  as node()* {\n");
            buff.append("       \n");
            buff.append("    for $seq in (1 to count($nodes))\n");
            buff.append("    return $nodes[$seq][not(functx:is-node-in-sequence(\n");
            buff.append("                                .,$nodes[position() < $seq]))]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Converts a timezone like \"-05:00\" or \"Z\" into xs:dayTimeDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_duration-from-timezone.html \n");
            buff.append(" : @param   $timezone the time zone, in (+|-)HH:MM format \n");
            buff.append(" :) \n");
            buff.append("declare function functx:duration-from-timezone \n");
            buff.append("  ( $timezone as xs:string )  as xs:dayTimeDuration {\n");
            buff.append("       \n");
            buff.append("   xs:dayTimeDuration(\n");
            buff.append("     if (not(matches($timezone,'Z|[\\+\\-]\\d{2}:\\d{2}')))\n");
            buff.append("     then error(xs:QName('functx:Invalid_Timezone_Value'))\n");
            buff.append("     else if ($timezone = 'Z')\n");
            buff.append("     then 'PT0S'\n");
            buff.append("     else replace($timezone,'\\+?(\\d{2}):\\d{2}','PT$1H')\n");
            buff.append("        )\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Dynamically evaluates a simple XPath path \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_dynamic-path.html \n");
            buff.append(" : @param   $parent the root to start from \n");
            buff.append(" : @param   $path the path expression \n");
            buff.append(" :) \n");
            buff.append("declare function functx:dynamic-path \n");
            buff.append("  ( $parent as node() ,\n");
            buff.append("    $path as xs:string )  as item()* {\n");
            buff.append("       \n");
            buff.append("  let $nextStep := functx:substring-before-if-contains($path,'/')\n");
            buff.append("  let $restOfSteps := substring-after($path,'/')\n");
            buff.append("  for $child in\n");
            buff.append("    ($parent/*[functx:name-test(name(),$nextStep)],\n");
            buff.append("     $parent/@*[functx:name-test(name(),\n");
            buff.append("                              substring-after($nextStep,'@'))])\n");
            buff.append("  return if ($restOfSteps)\n");
            buff.append("         then functx:dynamic-path($child, $restOfSteps)\n");
            buff.append("         else $child\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Escapes regex special characters \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_escape-for-regex.html \n");
            buff.append(" : @param   $arg the string to escape \n");
            buff.append(" :) \n");
            buff.append("declare function functx:escape-for-regex \n");
            buff.append("  ( $arg as xs:string? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace($arg,\n");
            buff.append("           '(\\.|\\[|\\]|\\\\|\\||\\-|\\^|\\$|\\?|\\*|\\+|\\{|\\}|\\(|\\))','\\\\$1')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether one (and only one) of two boolean values is true \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_exclusive-or.html \n");
            buff.append(" : @param   $arg1 the first boolean value \n");
            buff.append(" : @param   $arg2 the second boolean value \n");
            buff.append(" :) \n");
            buff.append("declare function functx:exclusive-or \n");
            buff.append("  ( $arg1 as xs:boolean? ,\n");
            buff.append("    $arg2 as xs:boolean? )  as xs:boolean? {\n");
            buff.append("       \n");
            buff.append("   $arg1 != $arg2\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The first day of the month of a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_first-day-of-month.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:first-day-of-month \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   functx:date(year-from-date(xs:date($date)),\n");
            buff.append("            month-from-date(xs:date($date)),\n");
            buff.append("            1)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The first day of the year of a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_first-day-of-year.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:first-day-of-year \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   functx:date(year-from-date(xs:date($date)), 1, 1)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The XML node in a sequence that appears first in document order \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_first-node.html \n");
            buff.append(" : @param   $nodes the sequence of nodes \n");
            buff.append(" :) \n");
            buff.append("declare function functx:first-node \n");
            buff.append("  ( $nodes as node()* )  as node()? {\n");
            buff.append("       \n");
            buff.append("   ($nodes/.)[1]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node follows another without being its descendant \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query Working Group \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html \n");
            buff.append(" : @param   $a the first node \n");
            buff.append(" : @param   $b the second node \n");
            buff.append(" :) \n");
            buff.append("declare function functx:follows-not-descendant \n");
            buff.append("  ( $a as node()? ,\n");
            buff.append("    $b as node()? )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $a >> $b and empty($b intersect $a/ancestor::node())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Moves title words like \"the\" and \"a\" to the end of strings \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_format-as-title-en.html \n");
            buff.append(" : @param   $titles the titles to format \n");
            buff.append(" :) \n");
            buff.append("declare function functx:format-as-title-en \n");
            buff.append("  ( $titles as xs:string* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   let $wordsToMoveToEnd := ('A', 'An', 'The')\n");
            buff.append("   for $title in $titles\n");
            buff.append("   let $firstWord := functx:substring-before-match($title,'\\W')\n");
            buff.append("   return if ($firstWord = $wordsToMoveToEnd)\n");
            buff.append("          then replace($title,'(.*?)\\W(.*)', '$2, $1')\n");
            buff.append("          else $title\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Returns the fragment from a URI \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html \n");
            buff.append(" : @param   $uri the URI \n");
            buff.append(" :) \n");
            buff.append("declare function functx:fragment-from-uri \n");
            buff.append("  ( $uri as xs:string? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   substring-after($uri,'#')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Splits a string into matching and non-matching regions \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_get-matches-and-non-matches.html \n");
            buff.append(" : @param   $string the string to split \n");
            buff.append(" : @param   $regex the pattern \n");
            buff.append(" :) \n");
            buff.append("declare function functx:get-matches-and-non-matches \n");
            buff.append("  ( $string as xs:string? ,\n");
            buff.append("    $regex as xs:string )  as element()* {\n");
            buff.append("       \n");
            buff.append("   let $iomf := functx:index-of-match-first($string, $regex)\n");
            buff.append("   return\n");
            buff.append("   if (empty($iomf))\n");
            buff.append("   then <non-match>{$string}</non-match>\n");
            buff.append("   else\n");
            buff.append("   if ($iomf > 1)\n");
            buff.append("   then (<non-match>{substring($string,1,$iomf - 1)}</non-match>,\n");
            buff.append("         functx:get-matches-and-non-matches(\n");
            buff.append("            substring($string,$iomf),$regex))\n");
            buff.append("   else\n");
            buff.append("   let $length :=\n");
            buff.append("      string-length($string) -\n");
            buff.append("      string-length(functx:replace-first($string, $regex,''))\n");
            buff.append("   return (<match>{substring($string,1,$length)}</match>,\n");
            buff.append("           if (string-length($string) > $length)\n");
            buff.append("           then functx:get-matches-and-non-matches(\n");
            buff.append("              substring($string,$length + 1),$regex)\n");
            buff.append("           else ())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Return the matching regions of a string \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_get-matches.html \n");
            buff.append(" : @param   $string the string to split \n");
            buff.append(" : @param   $regex the pattern \n");
            buff.append(" :) \n");
            buff.append("declare function functx:get-matches \n");
            buff.append("  ( $string as xs:string? ,\n");
            buff.append("    $regex as xs:string )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   functx:get-matches-and-non-matches($string,$regex)/\n");
            buff.append("     string(self::match)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an element has element-only content \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html \n");
            buff.append(" : @param   $element the XML element to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:has-element-only-content \n");
            buff.append("  ( $element as element() )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   not($element/text()[normalize-space(.) != '']) and $element/*\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an element has empty content \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_has-empty-content.html \n");
            buff.append(" : @param   $element the XML element to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:has-empty-content \n");
            buff.append("  ( $element as element() )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   not($element/node())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an element has mixed content \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html \n");
            buff.append(" : @param   $element the XML element to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:has-mixed-content \n");
            buff.append("  ( $element as element() )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $element/text()[normalize-space(.) != ''] and $element/*\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an element has simple content \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_has-simple-content.html \n");
            buff.append(" : @param   $element the XML element to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:has-simple-content \n");
            buff.append("  ( $element as element() )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $element/text() and not($element/*)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Gets the ID of an XML element \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_id-from-element.html \n");
            buff.append(" : @param   $element the element \n");
            buff.append(" :) \n");
            buff.append("declare function functx:id-from-element \n");
            buff.append("  ( $element as element()? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("  data(($element/@*[id(.) is ..])[1])\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Gets XML element(s) that have an attribute with a particular value \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_id-untyped.html \n");
            buff.append(" : @param   $node the root node(s) to start from \n");
            buff.append(" : @param   $id the \"id\" to find \n");
            buff.append(" :) \n");
            buff.append("declare function functx:id-untyped \n");
            buff.append("  ( $node as node()* ,\n");
            buff.append("    $id as xs:anyAtomicType )  as element()* {\n");
            buff.append("       \n");
            buff.append("  $node//*[@* = $id]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The first argument if it is not empty, otherwise the second argument \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query WG \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_if-absent.html \n");
            buff.append(" : @param   $arg the item(s) that may be absent \n");
            buff.append(" : @param   $value the item(s) to use if the item is absent \n");
            buff.append(" :) \n");
            buff.append("declare function functx:if-absent \n");
            buff.append("  ( $arg as item()* ,\n");
            buff.append("    $value as item()* )  as item()* {\n");
            buff.append("       \n");
            buff.append("    if (exists($arg))\n");
            buff.append("    then $arg\n");
            buff.append("    else $value\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The first argument if it is not blank, otherwise the second argument \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_if-empty.html \n");
            buff.append(" : @param   $arg the node that may be empty \n");
            buff.append(" : @param   $value the item(s) to use if the node is empty \n");
            buff.append(" :) \n");
            buff.append("declare function functx:if-empty \n");
            buff.append("  ( $arg as item()? ,\n");
            buff.append("    $value as item()* )  as item()* {\n");
            buff.append("       \n");
            buff.append("  if (string($arg) != '')\n");
            buff.append("  then data($arg)\n");
            buff.append("  else $value\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The position of a node in a sequence, based on contents and attributes \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html \n");
            buff.append(" : @param   $nodes the node sequence \n");
            buff.append(" : @param   $nodeToFind the node to find in the sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:index-of-deep-equal-node \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $nodeToFind as node() )  as xs:integer* {\n");
            buff.append("       \n");
            buff.append("  for $seq in (1 to count($nodes))\n");
            buff.append("  return $seq[deep-equal($nodes[$seq],$nodeToFind)]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The first position of a matching substring \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html \n");
            buff.append(" : @param   $arg the string \n");
            buff.append(" : @param   $pattern the pattern to match \n");
            buff.append(" :) \n");
            buff.append("declare function functx:index-of-match-first \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $pattern as xs:string )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("  if (matches($arg,$pattern))\n");
            buff.append("  then string-length(tokenize($arg, $pattern)[1]) + 1\n");
            buff.append("  else ()\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The position of a node in a sequence, based on node identity \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query Working Group \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_index-of-node.html \n");
            buff.append(" : @param   $nodes the node sequence \n");
            buff.append(" : @param   $nodeToFind the node to find in the sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:index-of-node \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $nodeToFind as node() )  as xs:integer* {\n");
            buff.append("       \n");
            buff.append("  for $seq in (1 to count($nodes))\n");
            buff.append("  return $seq[$nodes[$seq] is $nodeToFind]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The first position of a substring \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html \n");
            buff.append(" : @param   $arg the string \n");
            buff.append(" : @param   $substring the substring to find \n");
            buff.append(" :) \n");
            buff.append("declare function functx:index-of-string-first \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $substring as xs:string )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("  if (contains($arg, $substring))\n");
            buff.append("  then string-length(substring-before($arg, $substring))+1\n");
            buff.append("  else ()\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The last position of a substring \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html \n");
            buff.append(" : @param   $arg the string \n");
            buff.append(" : @param   $substring the substring to find \n");
            buff.append(" :) \n");
            buff.append("declare function functx:index-of-string-last \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $substring as xs:string )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("  functx:index-of-string($arg, $substring)[last()]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The position(s) of a substring \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_index-of-string.html \n");
            buff.append(" : @param   $arg the string \n");
            buff.append(" : @param   $substring the substring to find \n");
            buff.append(" :) \n");
            buff.append("declare function functx:index-of-string \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $substring as xs:string )  as xs:integer* {\n");
            buff.append("       \n");
            buff.append("  if (contains($arg, $substring))\n");
            buff.append("  then (string-length(substring-before($arg, $substring))+1,\n");
            buff.append("        for $other in\n");
            buff.append("           functx:index-of-string(substring-after($arg, $substring),\n");
            buff.append("                               $substring)\n");
            buff.append("        return\n");
            buff.append("          $other +\n");
            buff.append("          string-length(substring-before($arg, $substring)) +\n");
            buff.append("          string-length($substring))\n");
            buff.append("  else ()\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Inserts a string at a specified position \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_insert-string.html \n");
            buff.append(" : @param   $originalString the original string to insert into \n");
            buff.append(" : @param   $stringToInsert the string to insert \n");
            buff.append(" : @param   $pos the position \n");
            buff.append(" :) \n");
            buff.append("declare function functx:insert-string \n");
            buff.append("  ( $originalString as xs:string? ,\n");
            buff.append("    $stringToInsert as xs:string? ,\n");
            buff.append("    $pos as xs:integer )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   concat(substring($originalString,1,$pos - 1),\n");
            buff.append("             $stringToInsert,\n");
            buff.append("             substring($originalString,$pos))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a value is numeric \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-a-number.html \n");
            buff.append(" : @param   $value the value to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-a-number \n");
            buff.append("  ( $value as xs:anyAtomicType? )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   string(number($value)) != 'NaN'\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a URI is absolute \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html \n");
            buff.append(" : @param   $uri the URI to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-absolute-uri \n");
            buff.append("  ( $uri as xs:string? )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   matches($uri,'^[a-z]+:')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node is an ancestor of another node \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-ancestor.html \n");
            buff.append(" : @param   $node1 the first node \n");
            buff.append(" : @param   $node2 the second node \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-ancestor \n");
            buff.append("  ( $node1 as node() ,\n");
            buff.append("    $node2 as node() )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   exists($node1 intersect $node2/ancestor::node())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node is a descendant of another node \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-descendant.html \n");
            buff.append(" : @param   $node1 the first node \n");
            buff.append(" : @param   $node2 the second node \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-descendant \n");
            buff.append("  ( $node1 as node() ,\n");
            buff.append("    $node2 as node() )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   boolean($node2 intersect $node1/ancestor::node())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a date falls in a leap year \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-leap-year.html \n");
            buff.append(" : @param   $date the date or year \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-leap-year \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("    for $year in xs:integer(substring(string($date),1,4))\n");
            buff.append("    return ($year mod 4 = 0 and\n");
            buff.append("            $year mod 100 != 0) or\n");
            buff.append("            $year mod 400 = 0\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node is among the descendants of a sequence, based on contents and attributes \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html \n");
            buff.append(" : @param   $node the node to test \n");
            buff.append(" : @param   $seq the sequence of nodes to search \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-node-among-descendants-deep-equal \n");
            buff.append("  ( $node as node()? ,\n");
            buff.append("    $seq as node()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   some $nodeInSeq in $seq/descendant-or-self::*/(.|@*)\n");
            buff.append("   satisfies deep-equal($nodeInSeq,$node)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node is among the descendants of a sequence, based on node identity \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html \n");
            buff.append(" : @param   $node the node to test \n");
            buff.append(" : @param   $seq the sequence of nodes to search \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-node-among-descendants \n");
            buff.append("  ( $node as node()? ,\n");
            buff.append("    $seq as node()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   some $nodeInSeq in $seq/descendant-or-self::*/(.|@*)\n");
            buff.append("   satisfies $nodeInSeq is $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node is in a sequence, based on contents and attributes \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html \n");
            buff.append(" : @param   $node the node to test \n");
            buff.append(" : @param   $seq the sequence of nodes to search \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-node-in-sequence-deep-equal \n");
            buff.append("  ( $node as node()? ,\n");
            buff.append("    $seq as node()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node is in a sequence, based on node identity \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html \n");
            buff.append(" : @param   $node the node to test \n");
            buff.append(" : @param   $seq the sequence of nodes to search \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-node-in-sequence \n");
            buff.append("  ( $node as node()? ,\n");
            buff.append("    $seq as node()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   some $nodeInSeq in $seq satisfies $nodeInSeq is $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an atomic value appears in a sequence  \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html \n");
            buff.append(" : @param   $value the atomic value to test \n");
            buff.append(" : @param   $seq the sequence of values to search \n");
            buff.append(" :) \n");
            buff.append("declare function functx:is-value-in-sequence \n");
            buff.append("  ( $value as xs:anyAtomicType? ,\n");
            buff.append("    $seq as xs:anyAtomicType* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $value = $seq\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The last day of the month of a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_last-day-of-month.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:last-day-of-month \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   functx:date(year-from-date(xs:date($date)),\n");
            buff.append("            month-from-date(xs:date($date)),\n");
            buff.append("            functx:days-in-month($date))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The last day of the month of a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_last-day-of-year.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:last-day-of-year \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   functx:date(year-from-date(xs:date($date)), 12, 31)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The XML node in a sequence that is last in document order \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_last-node.html \n");
            buff.append(" : @param   $nodes the sequence of nodes \n");
            buff.append(" :) \n");
            buff.append("declare function functx:last-node \n");
            buff.append("  ( $nodes as node()* )  as node()? {\n");
            buff.append("       \n");
            buff.append("   ($nodes/.)[last()]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : All XML elements that don't have any child elements \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_leaf-elements.html \n");
            buff.append(" : @param   $root the root \n");
            buff.append(" :) \n");
            buff.append("declare function functx:leaf-elements \n");
            buff.append("  ( $root as node()? )  as element()* {\n");
            buff.append("       \n");
            buff.append("   $root/descendant-or-self::*[not(*)]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Trims leading whitespace \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_left-trim.html \n");
            buff.append(" : @param   $arg the string to trim \n");
            buff.append(" :) \n");
            buff.append("declare function functx:left-trim \n");
            buff.append("  ( $arg as xs:string? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace($arg,'^\\s+','')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The number of lines \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_line-count.html \n");
            buff.append(" : @param   $arg the string to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:line-count \n");
            buff.append("  ( $arg as xs:string? )  as xs:integer {\n");
            buff.append("       \n");
            buff.append("   count(functx:lines($arg))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Split a string into separate lines \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_lines.html \n");
            buff.append(" : @param   $arg the string to split \n");
            buff.append(" :) \n");
            buff.append("declare function functx:lines \n");
            buff.append("  ( $arg as xs:string? )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("   tokenize($arg, '(\\r\\n?|\\n\\r?)')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The maximum depth of elements in an XML tree \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_max-depth.html \n");
            buff.append(" : @param   $root the root to start from \n");
            buff.append(" :) \n");
            buff.append("declare function functx:max-depth \n");
            buff.append("  ( $root as node()? )  as xs:integer? {\n");
            buff.append("       \n");
            buff.append("   if ($root/*)\n");
            buff.append("   then max($root/*/functx:max-depth(.)) + 1\n");
            buff.append("   else 1\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The maximum value in a sequence, figuring out its type (numeric or string) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_max-determine-type.html \n");
            buff.append(" : @param   $seq the sequence of values to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:max-determine-type \n");
            buff.append("  ( $seq as xs:anyAtomicType* )  as xs:anyAtomicType? {\n");
            buff.append("       \n");
            buff.append("   if (every $value in $seq satisfies ($value castable as xs:double))\n");
            buff.append("   then max(for $value in $seq return xs:double($value))\n");
            buff.append("   else max(for $value in $seq return xs:string($value))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The maximum line length \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_max-line-length.html \n");
            buff.append(" : @param   $arg the string to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:max-line-length \n");
            buff.append("  ( $arg as xs:string? )  as xs:integer {\n");
            buff.append("       \n");
            buff.append("   max(\n");
            buff.append("     for $line in functx:lines($arg)\n");
            buff.append("     return string-length($line))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The XML node whose typed value is the maximum \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_max-node.html \n");
            buff.append(" : @param   $nodes the sequence of nodes to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:max-node \n");
            buff.append("  ( $nodes as node()* )  as node()* {\n");
            buff.append("       \n");
            buff.append("   $nodes[. = max($nodes)]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The maximum of a sequence of values, treating them like strings \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_max-string.html \n");
            buff.append(" : @param   $strings the sequence of values \n");
            buff.append(" :) \n");
            buff.append("declare function functx:max-string \n");
            buff.append("  ( $strings as xs:anyAtomicType* )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   max(for $string in $strings return string($string))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The minimum value in a sequence, figuring out its type (numeric or string) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_min-determine-type.html \n");
            buff.append(" : @param   $seq the sequence of values to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:min-determine-type \n");
            buff.append("  ( $seq as xs:anyAtomicType* )  as xs:anyAtomicType? {\n");
            buff.append("       \n");
            buff.append("   if (every $value in $seq satisfies ($value castable as xs:double))\n");
            buff.append("   then min(for $value in $seq return xs:double($value))\n");
            buff.append("   else min(for $value in $seq return xs:string($value))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The XML node whose typed value is the minimum \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_min-node.html \n");
            buff.append(" : @param   $nodes the sequence of nodes to test \n");
            buff.append(" :) \n");
            buff.append("declare function functx:min-node \n");
            buff.append("  ( $nodes as node()* )  as node()* {\n");
            buff.append("       \n");
            buff.append("   $nodes[. = min($nodes)]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The minimum of a sequence of strings, ignoring \"empty\" values \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_min-non-empty-string.html \n");
            buff.append(" : @param   $strings the sequence of strings to search \n");
            buff.append(" :) \n");
            buff.append("declare function functx:min-non-empty-string \n");
            buff.append("  ( $strings as xs:string* )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   min($strings[. != ''])\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The minimum of a sequence of values, treating them like strings \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_min-string.html \n");
            buff.append(" : @param   $strings the sequence of strings \n");
            buff.append(" :) \n");
            buff.append("declare function functx:min-string \n");
            buff.append("  ( $strings as xs:anyAtomicType* )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   min(for $string in $strings return string($string))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Converts a string with format MMDDYYYY (with any delimiters) to a date \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_mmddyyyy-to-date.html \n");
            buff.append(" : @param   $dateString the MMDDYYYY string \n");
            buff.append(" :) \n");
            buff.append("declare function functx:mmddyyyy-to-date \n");
            buff.append("  ( $dateString as xs:string? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   if (empty($dateString))\n");
            buff.append("   then ()\n");
            buff.append("   else if (not(matches($dateString,\n");
            buff.append("                        '^\\D*(\\d{2})\\D*(\\d{2})\\D*(\\d{4})\\D*$')))\n");
            buff.append("   then error(xs:QName('functx:Invalid_Date_Format'))\n");
            buff.append("   else xs:date(replace($dateString,\n");
            buff.append("                        '^\\D*(\\d{2})\\D*(\\d{2})\\D*(\\d{4})\\D*$',\n");
            buff.append("                        '$3-$1-$2'))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The month of a date as an abbreviated word (Jan, Feb, etc.) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:month-abbrev-en \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n");
            buff.append("    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')\n");
            buff.append("    [month-from-date(xs:date($date))]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The month of a date as a word (January, February, etc.) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_month-name-en.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:month-name-en \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   ('January', 'February', 'March', 'April', 'May', 'June',\n");
            buff.append("    'July', 'August', 'September', 'October', 'November', 'December')\n");
            buff.append("   [month-from-date(xs:date($date))]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether a name matches a list of names or name wildcards \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_name-test.html \n");
            buff.append(" : @param   $testname the name to test \n");
            buff.append(" : @param   $names the list of names or name wildcards \n");
            buff.append(" :) \n");
            buff.append("declare function functx:name-test \n");
            buff.append("  ( $testname as xs:string? ,\n");
            buff.append("    $names as xs:string* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("$testname = $names\n");
            buff.append("or\n");
            buff.append("$names = '*'\n");
            buff.append("or\n");
            buff.append("functx:substring-after-if-contains($testname,':') =\n");
            buff.append("   (for $name in $names\n");
            buff.append("   return substring-after($name,'*:'))\n");
            buff.append("or\n");
            buff.append("substring-before($testname,':') =\n");
            buff.append("   (for $name in $names[contains(.,':*')]\n");
            buff.append("   return substring-before($name,':*'))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : A list of namespaces used in element/attribute names in an XML fragment \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_namespaces-in-use.html \n");
            buff.append(" : @param   $root the root node to start from \n");
            buff.append(" :) \n");
            buff.append("declare function functx:namespaces-in-use \n");
            buff.append("  ( $root as node()? )  as xs:anyURI* {\n");
            buff.append("       \n");
            buff.append("   distinct-values(\n");
            buff.append("      $root/descendant-or-self::*/(.|@*)/namespace-uri(.))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The next day \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_next-day.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:next-day \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   xs:date($date) + xs:dayTimeDuration('P1D')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The XML node kind (element, attribute, text, etc.) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_node-kind.html \n");
            buff.append(" : @param   $nodes the node(s) whose kind you want to determine \n");
            buff.append(" :) \n");
            buff.append("declare function functx:node-kind \n");
            buff.append("  ( $nodes as node()* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append(" for $node in $nodes\n");
            buff.append(" return\n");
            buff.append(" if ($node instance of element()) then 'element'\n");
            buff.append(" else if ($node instance of attribute()) then 'attribute'\n");
            buff.append(" else if ($node instance of text()) then 'text'\n");
            buff.append(" else if ($node instance of document-node()) then 'document-node'\n");
            buff.append(" else if ($node instance of comment()) then 'comment'\n");
            buff.append(" else if ($node instance of processing-instruction())\n");
            buff.append("         then 'processing-instruction'\n");
            buff.append(" else 'unknown'\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Returns any values that appear more than once in a sequence \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_non-distinct-values.html \n");
            buff.append(" : @param   $seq the sequence of values \n");
            buff.append(" :) \n");
            buff.append("declare function functx:non-distinct-values \n");
            buff.append("  ( $seq as xs:anyAtomicType* )  as xs:anyAtomicType* {\n");
            buff.append("       \n");
            buff.append("   for $val in distinct-values($seq)\n");
            buff.append("   return $val[count($seq[. = $val]) > 1]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The number of regions that match a pattern \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_number-of-matches.html \n");
            buff.append(" : @param   $arg the string to test \n");
            buff.append(" : @param   $pattern the regular expression \n");
            buff.append(" :) \n");
            buff.append("declare function functx:number-of-matches \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $pattern as xs:string )  as xs:integer {\n");
            buff.append("       \n");
            buff.append("   count(tokenize($arg,$pattern)) - 1\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Resolves a relative URI and references it, returning an XML document \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_open-ref-document.html \n");
            buff.append(" : @param   $refNode a node whose value is a relative URI reference \n");
            buff.append(" :) \n");
            buff.append("declare function functx:open-ref-document \n");
            buff.append("  ( $refNode as node() )  as document-node() {\n");
            buff.append("       \n");
            buff.append("   if (base-uri($refNode))\n");
            buff.append("   then doc(resolve-uri($refNode, base-uri($refNode)))\n");
            buff.append("   else doc(resolve-uri($refNode))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html \n");
            buff.append(" : @param   $num the number \n");
            buff.append(" :) \n");
            buff.append("declare function functx:ordinal-number-en \n");
            buff.append("  ( $num as xs:integer? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   concat(xs:string($num),\n");
            buff.append("         if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th'\n");
            buff.append("         else if (ends-with(xs:string($num),'1')) then 'st'\n");
            buff.append("         else if (ends-with(xs:string($num),'2')) then 'nd'\n");
            buff.append("         else if (ends-with(xs:string($num),'3')) then 'rd'\n");
            buff.append("         else '')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Pads an integer to a desired length by adding leading zeros \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_pad-integer-to-length.html \n");
            buff.append(" : @param   $integerToPad the integer to pad \n");
            buff.append(" : @param   $length the desired length \n");
            buff.append(" :) \n");
            buff.append("declare function functx:pad-integer-to-length \n");
            buff.append("  ( $integerToPad as xs:anyAtomicType? ,\n");
            buff.append("    $length as xs:integer )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   if ($length < string-length(string($integerToPad)))\n");
            buff.append("   then error(xs:QName('functx:Integer_Longer_Than_Length'))\n");
            buff.append("   else concat\n");
            buff.append("         (functx:repeat-string(\n");
            buff.append("            '0',$length - string-length(string($integerToPad))),\n");
            buff.append("          string($integerToPad))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Pads a string to a desired length \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html \n");
            buff.append(" : @param   $stringToPad the string to pad \n");
            buff.append(" : @param   $padChar the character(s) to use as padding \n");
            buff.append(" : @param   $length the desired length \n");
            buff.append(" :) \n");
            buff.append("declare function functx:pad-string-to-length \n");
            buff.append("  ( $stringToPad as xs:string? ,\n");
            buff.append("    $padChar as xs:string ,\n");
            buff.append("    $length as xs:integer )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   substring(\n");
            buff.append("     string-join (\n");
            buff.append("       ($stringToPad, for $i in (1 to $length) return $padChar)\n");
            buff.append("       ,'')\n");
            buff.append("    ,1,$length)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : A unique path to an XML node (or sequence of nodes) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html \n");
            buff.append(" : @param   $node the node sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:path-to-node-with-pos \n");
            buff.append("  ( $node as node()? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("string-join(\n");
            buff.append("  for $ancestor in $node/ancestor-or-self::*\n");
            buff.append("  let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)]\n");
            buff.append("  return concat(name($ancestor),\n");
            buff.append("   if (count($sibsOfSameName) <= 1)\n");
            buff.append("   then ''\n");
            buff.append("   else concat(\n");
            buff.append("      '[',functx:index-of-node($sibsOfSameName,$ancestor),']'))\n");
            buff.append(" , '/')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : A path to an XML node (or sequence of nodes) \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_path-to-node.html \n");
            buff.append(" : @param   $nodes the node sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:path-to-node \n");
            buff.append("  ( $nodes as node()* )  as xs:string* {\n");
            buff.append("       \n");
            buff.append("$nodes/string-join(ancestor-or-self::*/name(.), '/')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether an XML node precedes another without being its ancestor \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query Working Group \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html \n");
            buff.append(" : @param   $a the first node \n");
            buff.append(" : @param   $b the second node \n");
            buff.append(" :) \n");
            buff.append("declare function functx:precedes-not-ancestor \n");
            buff.append("  ( $a as node()? ,\n");
            buff.append("    $b as node()? )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("   $a << $b and empty($a intersect $b/ancestor::node())\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The previous day \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_previous-day.html \n");
            buff.append(" : @param   $date the date \n");
            buff.append(" :) \n");
            buff.append("declare function functx:previous-day \n");
            buff.append("  ( $date as xs:anyAtomicType? )  as xs:date? {\n");
            buff.append("       \n");
            buff.append("   xs:date($date) - xs:dayTimeDuration('P1D')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Removes attributes from an XML fragment, based on name \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html \n");
            buff.append(" : @param   $nodes the root(s) to start from \n");
            buff.append(" : @param   $names the names of the attributes to remove, or * for all attributes \n");
            buff.append(" :) \n");
            buff.append("declare function functx:remove-attributes-deep \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $names as xs:string* )  as node()* {\n");
            buff.append("       \n");
            buff.append("   for $node in $nodes\n");
            buff.append("   return if ($node instance of element())\n");
            buff.append("          then  element { node-name($node)}\n");
            buff.append("                { $node/@*[not(functx:name-test(name(),$names))],\n");
            buff.append("                  functx:remove-attributes-deep($node/node(), $names)}\n");
            buff.append("          else if ($node instance of document-node())\n");
            buff.append("          then functx:remove-attributes-deep($node/node(), $names)\n");
            buff.append("          else $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Removes attributes from an XML element, based on name \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_remove-attributes.html \n");
            buff.append(" : @param   $elements the element(s) from which to remove the attributes \n");
            buff.append(" : @param   $names the names of the attributes to remove, or * for all attributes \n");
            buff.append(" :) \n");
            buff.append("declare function functx:remove-attributes \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $names as xs:string* )  as element() {\n");
            buff.append("       \n");
            buff.append("   for $element in $elements\n");
            buff.append("   return element\n");
            buff.append("     {node-name($element)}\n");
            buff.append("     {$element/@*[not(functx:name-test(name(),$names))],\n");
            buff.append("      $element/node() }\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Removes descendant elements from an XML node, based on name \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html \n");
            buff.append(" : @param   $nodes root(s) to start from \n");
            buff.append(" : @param   $names the names of the elements to remove \n");
            buff.append(" :) \n");
            buff.append("declare function functx:remove-elements-deep \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $names as xs:string* )  as node()* {\n");
            buff.append("       \n");
            buff.append("   for $node in $nodes\n");
            buff.append("   return\n");
            buff.append("     if ($node instance of element())\n");
            buff.append("     then if (functx:name-test(name($node),$names))\n");
            buff.append("          then ()\n");
            buff.append("          else element { node-name($node)}\n");
            buff.append("                { $node/@*,\n");
            buff.append("                  functx:remove-elements-deep($node/node(), $names)}\n");
            buff.append("     else if ($node instance of document-node())\n");
            buff.append("     then functx:remove-elements-deep($node/node(), $names)\n");
            buff.append("     else $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Removes descendant XML elements but keeps their content \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html \n");
            buff.append(" : @param   $nodes the root(s) to start from \n");
            buff.append(" : @param   $names the names of the elements to remove \n");
            buff.append(" :) \n");
            buff.append("declare function functx:remove-elements-not-contents \n");
            buff.append("  ( $nodes as node()* ,\n");
            buff.append("    $names as xs:string* )  as node()* {\n");
            buff.append("       \n");
            buff.append("   for $node in $nodes\n");
            buff.append("   return\n");
            buff.append("    if ($node instance of element())\n");
            buff.append("    then if (functx:name-test(name($node),$names))\n");
            buff.append("         then functx:remove-elements-not-contents($node/node(), $names)\n");
            buff.append("         else element {node-name($node)}\n");
            buff.append("              {$node/@*,\n");
            buff.append("              functx:remove-elements-not-contents($node/node(),$names)}\n");
            buff.append("    else if ($node instance of document-node())\n");
            buff.append("    then functx:remove-elements-not-contents($node/node(), $names)\n");
            buff.append("    else $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Removes child elements from an XML node, based on name \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_remove-elements.html \n");
            buff.append(" : @param   $elements the element(s) from which you wish to remove the children \n");
            buff.append(" : @param   $names the names of the child elements to remove \n");
            buff.append(" :) \n");
            buff.append("declare function functx:remove-elements \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $names as xs:string* )  as element()* {\n");
            buff.append("       \n");
            buff.append("   for $element in $elements\n");
            buff.append("   return element\n");
            buff.append("     {node-name($element)}\n");
            buff.append("     {$element/@*,\n");
            buff.append("      $element/node()[not(functx:name-test(name(),$names))] }\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Repeats a string a given number of times \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_repeat-string.html \n");
            buff.append(" : @param   $stringToRepeat the string to repeat \n");
            buff.append(" : @param   $count the desired number of copies \n");
            buff.append(" :) \n");
            buff.append("declare function functx:repeat-string \n");
            buff.append("  ( $stringToRepeat as xs:string? ,\n");
            buff.append("    $count as xs:integer )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   string-join((for $i in 1 to $count return $stringToRepeat),\n");
            buff.append("                        '')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Replaces the beginning of a string, up to a matched pattern \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_replace-beginning.html \n");
            buff.append(" : @param   $arg the entire string to change \n");
            buff.append(" : @param   $pattern the pattern of characters to replace up to \n");
            buff.append(" : @param   $replacement the replacement string \n");
            buff.append(" :) \n");
            buff.append("declare function functx:replace-beginning \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $pattern as xs:string ,\n");
            buff.append("    $replacement as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace($arg, concat('^.*?', $pattern), $replacement)\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Updates the content of one or more elements \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_replace-element-values.html \n");
            buff.append(" : @param   $elements the elements whose content you wish to replace \n");
            buff.append(" : @param   $values the replacement values \n");
            buff.append(" :) \n");
            buff.append("declare function functx:replace-element-values \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $values as xs:anyAtomicType* )  as element()* {\n");
            buff.append("       \n");
            buff.append("   for $element at $seq in $elements\n");
            buff.append("   return element { node-name($element)}\n");
            buff.append("             { $element/@*,\n");
            buff.append("               $values[$seq] }\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Replaces the first match of a pattern \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_replace-first.html \n");
            buff.append(" : @param   $arg the entire string to change \n");
            buff.append(" : @param   $pattern the pattern of characters to replace \n");
            buff.append(" : @param   $replacement the replacement string \n");
            buff.append(" :) \n");
            buff.append("declare function functx:replace-first \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $pattern as xs:string ,\n");
            buff.append("    $replacement as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace($arg, concat('(^.*?)', $pattern),\n");
            buff.append("             concat('$1',$replacement))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Performs multiple replacements, using pairs of replace parameters \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_replace-multi.html \n");
            buff.append(" : @param   $arg the string to manipulate \n");
            buff.append(" : @param   $changeFrom the sequence of strings or patterns to change from \n");
            buff.append(" : @param   $changeTo the sequence of strings to change to \n");
            buff.append(" :) \n");
            buff.append("declare function functx:replace-multi \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $changeFrom as xs:string* ,\n");
            buff.append("    $changeTo as xs:string* )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   if (count($changeFrom) > 0)\n");
            buff.append("   then functx:replace-multi(\n");
            buff.append("          replace($arg, $changeFrom[1],\n");
            buff.append("                     functx:if-absent($changeTo[1],'')),\n");
            buff.append("          $changeFrom[position() > 1],\n");
            buff.append("          $changeTo[position() > 1])\n");
            buff.append("   else $arg\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Reverses the order of characters \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_reverse-string.html \n");
            buff.append(" : @param   $arg the string to reverse \n");
            buff.append(" :) \n");
            buff.append("declare function functx:reverse-string \n");
            buff.append("  ( $arg as xs:string? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   codepoints-to-string(reverse(string-to-codepoints($arg)))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Trims trailing whitespace \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_right-trim.html \n");
            buff.append(" : @param   $arg the string to trim \n");
            buff.append(" :) \n");
            buff.append("declare function functx:right-trim \n");
            buff.append("  ( $arg as xs:string? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace($arg,'\\s+$','')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Returns the scheme from a URI \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html \n");
            buff.append(" : @param   $uri the URI \n");
            buff.append(" :) \n");
            buff.append("declare function functx:scheme-from-uri \n");
            buff.append("  ( $uri as xs:string? )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   substring-before($uri,':')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether two sequences have the same XML node content and/or values \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html \n");
            buff.append(" : @param   $seq1 the first sequence \n");
            buff.append(" : @param   $seq2 the second sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sequence-deep-equal \n");
            buff.append("  ( $seq1 as item()* ,\n");
            buff.append("    $seq2 as item()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("  every $i in 1 to max((count($seq1),count($seq2)))\n");
            buff.append("  satisfies deep-equal($seq1[$i],$seq2[$i])\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether two sequences contain the same XML nodes, regardless of order \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html \n");
            buff.append(" : @param   $seq1 the first sequence of nodes \n");
            buff.append(" : @param   $seq2 the second sequence of nodes \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sequence-node-equal-any-order \n");
            buff.append("  ( $seq1 as node()* ,\n");
            buff.append("    $seq2 as node()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("  not( ($seq1 except $seq2, $seq2 except $seq1))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Whether two sequences contain the same XML nodes, in the same order \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html \n");
            buff.append(" : @param   $seq1 the first sequence of nodes \n");
            buff.append(" : @param   $seq2 the second sequence of nodes \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sequence-node-equal \n");
            buff.append("  ( $seq1 as node()* ,\n");
            buff.append("    $seq2 as node()* )  as xs:boolean {\n");
            buff.append("       \n");
            buff.append("  every $i in 1 to max((count($seq1),count($seq2)))\n");
            buff.append("  satisfies $seq1[$i] is $seq2[$i]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The sequence type that represents a sequence of nodes or values \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sequence-type.html \n");
            buff.append(" : @param   $items the items whose sequence type you want to determine \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sequence-type \n");
            buff.append("  ( $items as item()* )  as xs:string {\n");
            buff.append("       \n");
            buff.append("concat(\n");
            buff.append("  if (empty($items))\n");
            buff.append("  then 'empty-sequence()'\n");
            buff.append("  else if (every $val in $items\n");
            buff.append("           satisfies $val instance of xs:anyAtomicType)\n");
            buff.append("  then if (count(distinct-values(functx:atomic-type($items)))\n");
            buff.append("           > 1)\n");
            buff.append("  then 'xs:anyAtomicType'\n");
            buff.append("  else functx:atomic-type($items[1])\n");
            buff.append("  else if (some $val in $items\n");
            buff.append("           satisfies $val instance of xs:anyAtomicType)\n");
            buff.append("  then 'item()'\n");
            buff.append("  else if (count(distinct-values(functx:node-kind($items))) > 1)\n");
            buff.append("  then 'node()'\n");
            buff.append("  else concat(functx:node-kind($items[1]),'()')\n");
            buff.append("  ,\n");
            buff.append("  if (count($items) > 1)\n");
            buff.append("  then '+' else '')\n");
            buff.append("   } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The siblings of an XML element that have the same name \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html \n");
            buff.append(" : @param   $element the node \n");
            buff.append(" :) \n");
            buff.append("declare function functx:siblings-same-name \n");
            buff.append("  ( $element as element()? )  as element()* {\n");
            buff.append("       \n");
            buff.append("   $element/../*[node-name(.) = node-name($element)]\n");
            buff.append("   except $element\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The siblings of an XML node \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_siblings.html \n");
            buff.append(" : @param   $node the node \n");
            buff.append(" :) \n");
            buff.append("declare function functx:siblings \n");
            buff.append("  ( $node as node()? )  as node()* {\n");
            buff.append("       \n");
            buff.append("   $node/../node() except $node\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Sorts a sequence of numeric values or nodes \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html \n");
            buff.append(" : @param   $seq the sequence to sort \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sort-as-numeric \n");
            buff.append("  ( $seq as item()* )  as item()* {\n");
            buff.append("       \n");
            buff.append("   for $item in $seq\n");
            buff.append("   order by number($item)\n");
            buff.append("   return $item\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Sorts a sequence of values or nodes regardless of capitalization \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html \n");
            buff.append(" : @param   $seq the sequence to sort \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sort-case-insensitive \n");
            buff.append("  ( $seq as item()* )  as item()* {\n");
            buff.append("       \n");
            buff.append("   for $item in $seq\n");
            buff.append("   order by upper-case(string($item))\n");
            buff.append("   return $item\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Sorts a sequence of nodes in document order \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sort-document-order.html \n");
            buff.append(" : @param   $seq the sequence to sort \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sort-document-order \n");
            buff.append("  ( $seq as node()* )  as node()* {\n");
            buff.append("       \n");
            buff.append("   $seq/.\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Sorts a sequence of values or nodes \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_sort.html \n");
            buff.append(" : @param   $seq the sequence to sort \n");
            buff.append(" :) \n");
            buff.append("declare function functx:sort \n");
            buff.append("  ( $seq as item()* )  as item()* {\n");
            buff.append("       \n");
            buff.append("   for $item in $seq\n");
            buff.append("   order by $item\n");
            buff.append("   return $item\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Performs substring-after, returning the entire string if it does not contain the delimiter \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $delim the delimiter \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-after-if-contains \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $delim as xs:string )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   if (contains($arg,$delim))\n");
            buff.append("   then substring-after($arg,$delim)\n");
            buff.append("   else $arg\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The substring after the last text that matches a regex \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-after-last-match.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $regex the regular expression \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-after-last-match \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $regex as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace($arg,concat('^.*',$regex),'')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The substring after the last occurrence of a delimiter \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-after-last.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $delim the delimiter \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-after-last \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $delim as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace ($arg,concat('^.*',functx:escape-for-regex($delim)),'')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The substring after the first text that matches a regex \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-after-match.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $regex the regular expression \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-after-match \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $regex as xs:string )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   replace($arg,concat('^.*?',$regex),'')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Performs substring-before, returning the entire string if it does not contain the delimiter \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $delim the delimiter \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-before-if-contains \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $delim as xs:string )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   if (contains($arg,$delim))\n");
            buff.append("   then substring-before($arg,$delim)\n");
            buff.append("   else $arg\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The substring after the first text that matches a regex \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-before-last-match.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $regex the regular expression \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-before-last-match \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $regex as xs:string )  as xs:string? {\n");
            buff.append("       \n");
            buff.append("   replace($arg,concat('^(.*)',$regex,'.*'),'$1')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The substring before the last occurrence of a delimiter \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-before-last.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $delim the delimiter \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-before-last \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $delim as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   if (matches($arg, functx:escape-for-regex($delim)))\n");
            buff.append("   then replace($arg,\n");
            buff.append("            concat('^(.*)', functx:escape-for-regex($delim),'.*'),\n");
            buff.append("            '$1')\n");
            buff.append("   else ''\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The substring before the last text that matches a regex \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_substring-before-match.html \n");
            buff.append(" : @param   $arg the string to substring \n");
            buff.append(" : @param   $regex the regular expression \n");
            buff.append(" :) \n");
            buff.append("declare function functx:substring-before-match \n");
            buff.append("  ( $arg as xs:string? ,\n");
            buff.append("    $regex as xs:string )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   tokenize($arg,$regex)[1]\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Construct a time from an hour, minute and second \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_time.html \n");
            buff.append(" : @param   $hour the hour \n");
            buff.append(" : @param   $minute the minute \n");
            buff.append(" : @param   $second the second \n");
            buff.append(" :) \n");
            buff.append("declare function functx:time \n");
            buff.append("  ( $hour as xs:anyAtomicType ,\n");
            buff.append("    $minute as xs:anyAtomicType ,\n");
            buff.append("    $second as xs:anyAtomicType )  as xs:time {\n");
            buff.append("       \n");
            buff.append("   xs:time(\n");
            buff.append("     concat(\n");
            buff.append("       functx:pad-integer-to-length(xs:integer($hour),2),':',\n");
            buff.append("       functx:pad-integer-to-length(xs:integer($minute),2),':',\n");
            buff.append("       functx:pad-integer-to-length(xs:integer($second),2)))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Converts an xs:dayTimeDuration into a timezone like \"-05:00\" or \"Z\" \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_timezone-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:timezone-from-duration \n");
            buff.append("  ( $duration as xs:dayTimeDuration )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   if (string($duration) = ('PT0S','-PT0S'))\n");
            buff.append("   then 'Z'\n");
            buff.append("   else if (matches(string($duration),'-PT[1-9]H'))\n");
            buff.append("   then replace(string($duration),'PT([1-9])H','0$1:00')\n");
            buff.append("   else if (matches(string($duration),'PT[1-9]H'))\n");
            buff.append("   then replace(string($duration),'PT([1-9])H','+0$1:00')\n");
            buff.append("   else if (matches(string($duration),'-PT1[0-4]H'))\n");
            buff.append("   then replace(string($duration),'PT(1[0-4])H','$1:00')\n");
            buff.append("   else if (matches(string($duration),'PT1[0-4]H'))\n");
            buff.append("   then replace(string($duration),'PT(1[0-4])H','+$1:00')\n");
            buff.append("   else error(xs:QName('functx:Invalid_Duration_Value'))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The total number of days in a dayTimeDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:total-days-from-duration \n");
            buff.append("  ( $duration as xs:dayTimeDuration? )  as xs:decimal? {\n");
            buff.append("       \n");
            buff.append("   $duration div xs:dayTimeDuration('P1D')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The total number of hours in a dayTimeDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:total-hours-from-duration \n");
            buff.append("  ( $duration as xs:dayTimeDuration? )  as xs:decimal? {\n");
            buff.append("       \n");
            buff.append("   $duration div xs:dayTimeDuration('PT1H')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The total number of minutes in a dayTimeDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:total-minutes-from-duration \n");
            buff.append("  ( $duration as xs:dayTimeDuration? )  as xs:decimal? {\n");
            buff.append("       \n");
            buff.append("   $duration div xs:dayTimeDuration('PT1M')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The total number of months in a yearMonthDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:total-months-from-duration \n");
            buff.append("  ( $duration as xs:yearMonthDuration? )  as xs:decimal? {\n");
            buff.append("       \n");
            buff.append("   $duration div xs:yearMonthDuration('P1M')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The total number of seconds in a dayTimeDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:total-seconds-from-duration \n");
            buff.append("  ( $duration as xs:dayTimeDuration? )  as xs:decimal? {\n");
            buff.append("       \n");
            buff.append("   $duration div xs:dayTimeDuration('PT1S')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The total number of years in a yearMonthDuration \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html \n");
            buff.append(" : @param   $duration the duration \n");
            buff.append(" :) \n");
            buff.append("declare function functx:total-years-from-duration \n");
            buff.append("  ( $duration as xs:yearMonthDuration? )  as xs:decimal? {\n");
            buff.append("       \n");
            buff.append("   $duration div xs:yearMonthDuration('P1Y')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Trims leading and trailing whitespace \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_trim.html \n");
            buff.append(" : @param   $arg the string to trim \n");
            buff.append(" :) \n");
            buff.append("declare function functx:trim \n");
            buff.append("  ( $arg as xs:string? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("   replace(replace($arg,'\\s+$',''),'^\\s+','')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Updates the attribute value of an XML element \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_update-attributes.html \n");
            buff.append(" : @param   $elements the element(s) for which you wish to update the attribute \n");
            buff.append(" : @param   $attrNames the name(s) of the attribute(s) to add \n");
            buff.append(" : @param   $attrValues the value(s) of the attribute(s) to add \n");
            buff.append(" :) \n");
            buff.append("declare function functx:update-attributes \n");
            buff.append("  ( $elements as element()* ,\n");
            buff.append("    $attrNames as xs:QName* ,\n");
            buff.append("    $attrValues as xs:anyAtomicType* )  as element()? {\n");
            buff.append("       \n");
            buff.append("   for $element in $elements\n");
            buff.append("   return element { node-name($element)}\n");
            buff.append("                  { for $attrName at $seq in $attrNames\n");
            buff.append("                    return if ($element/@*[node-name(.) = $attrName])\n");
            buff.append("                           then attribute {$attrName}\n");
            buff.append("                                     {$attrValues[$seq]}\n");
            buff.append("                           else (),\n");
            buff.append("                    $element/@*[not(node-name(.) = $attrNames)],\n");
            buff.append("                    $element/node() }\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The values in one sequence that aren't in another sequence \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query Working Group \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_value-except.html \n");
            buff.append(" : @param   $arg1 the first sequence \n");
            buff.append(" : @param   $arg2 the second sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:value-except \n");
            buff.append("  ( $arg1 as xs:anyAtomicType* ,\n");
            buff.append("    $arg2 as xs:anyAtomicType* )  as xs:anyAtomicType* {\n");
            buff.append("       \n");
            buff.append("  distinct-values($arg1[not(.=$arg2)])\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The intersection of two sequences of values \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query Working Group \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_value-intersect.html \n");
            buff.append(" : @param   $arg1 the first sequence \n");
            buff.append(" : @param   $arg2 the second sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:value-intersect \n");
            buff.append("  ( $arg1 as xs:anyAtomicType* ,\n");
            buff.append("    $arg2 as xs:anyAtomicType* )  as xs:anyAtomicType* {\n");
            buff.append("       \n");
            buff.append("  distinct-values($arg1[.=$arg2])\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The union of two sequences of values \n");
            buff.append(" :\n");
            buff.append(" : @author  W3C XML Query Working Group \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_value-union.html \n");
            buff.append(" : @param   $arg1 the first sequence \n");
            buff.append(" : @param   $arg2 the second sequence \n");
            buff.append(" :) \n");
            buff.append("declare function functx:value-union \n");
            buff.append("  ( $arg1 as xs:anyAtomicType* ,\n");
            buff.append("    $arg2 as xs:anyAtomicType* )  as xs:anyAtomicType* {\n");
            buff.append("       \n");
            buff.append("  distinct-values(($arg1, $arg2))\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : The number of words \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_word-count.html \n");
            buff.append(" : @param   $arg the string to measure \n");
            buff.append(" :) \n");
            buff.append("declare function functx:word-count \n");
            buff.append("  ( $arg as xs:string? )  as xs:integer {\n");
            buff.append("       \n");
            buff.append("   count(tokenize($arg, '\\W+')[. != ''])\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Turns a string of words into camelCase \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html \n");
            buff.append(" : @param   $arg the string to modify \n");
            buff.append(" :) \n");
            buff.append("declare function functx:words-to-camel-case \n");
            buff.append("  ( $arg as xs:string? )  as xs:string {\n");
            buff.append("       \n");
            buff.append("     string-join((tokenize($arg,'\\s+')[1],\n");
            buff.append("       for $word in tokenize($arg,'\\s+')[position() > 1]\n");
            buff.append("       return functx:capitalize-first($word))\n");
            buff.append("      ,'')\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Wraps a sequence of atomic values in XML elements \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html \n");
            buff.append(" : @param   $values the values to wrap in elements \n");
            buff.append(" : @param   $elementName the name of the elements to construct \n");
            buff.append(" :) \n");
            buff.append("declare function functx:wrap-values-in-elements \n");
            buff.append("  ( $values as xs:anyAtomicType* ,\n");
            buff.append("    $elementName as xs:QName )  as element()* {\n");
            buff.append("       \n");
            buff.append("   for $value in $values\n");
            buff.append("   return element {$elementName} {$value}\n");
            buff.append(" } ;\n");
            buff.append("\n");
            buff.append("(:~\n");
            buff.append(" : Construct a yearMonthDuration from a number of years and months \n");
            buff.append(" :\n");
            buff.append(" : @author  Priscilla Walmsley, Datypic \n");
            buff.append(" : @version 1.0 \n");
            buff.append(" : @see     http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html \n");
            buff.append(" : @param   $years the number of years \n");
            buff.append(" : @param   $months the number of months \n");
            buff.append(" :) \n");
            buff.append("declare function functx:yearMonthDuration \n");
            buff.append("  ( $years as xs:decimal? ,\n");
            buff.append("    $months as xs:integer? )  as xs:yearMonthDuration {\n");
            buff.append("       \n");
            buff.append("    (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) +\n");
            buff.append("    (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0))\n");
            buff.append(" } ;\n");
            InputStream is = new ByteArrayInputStream(buff.toString().getBytes());
            XQDocPayload payload = controller.process(is, "");
            System.out.println(payload.getXQDocXML());
        } catch (XQDocException e) {
            e.printStackTrace();
        }
    }
}
